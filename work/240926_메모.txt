1. 스프링부트 추가하기
https://start.spring.io/

Gradle - Groovy
java
3.3.4
Group: 조직이나 프로젝트 그룹을 식별하는 네임스페이스 역할. (ex: com.example)
Artifact: 프로젝트의 고유 이름으로, 빌드된 결과물의 파일 이름. (ex: my-web-app) --겹치면 안된다.
com.korea
di
package : 어떻게 배포할것인가

Add dependencies ->Spring Web, Lombok, Spring Data JPA,H2 Database, (DevTools) ->generate

이클립스에서 프로젝트 import하기 

압축 해제(여기에풀기)한 프로젝트를 이클립스에서 열기 위해 이클립스 실행한 후 File > import를 선택한다.
Existing Gradle Project ->
Browse눌러서 프로젝트의 경로를 설정해준다.
Next를 눌러서 Import Option으로 간다.
Override workspace settings를 체크한다.
Gradle distribution에서 Gradle wrapper를 선택한다.
이 작업을 해야 하는 이유는 윈도우에 Gradle을 설치하지 않았기 때문이다.
대신 Spring Initializr에서 프로젝트를 다운로드 할 때 gradlew라는 프로그램을 같이 받았기 때문에 따로 설치할 필요가 없다.

src/main/resources-> application.properties-> server.port=9090 추가
DemoApplication.java -> 실행
브라우저 -> http://localhost:9090/


2. 스프링부트 프로젝트의 구성
src/main/java : 서버단 Java파일 
test/main/java : 단위 테스트 Java파일
src/main/resources : 설정 파일 및 View단
src/main/resources/static : css,js,image 등 정적 파일 경로
src/main/resources/templates : html 파일 경로
build.gradle : 라이브러리 의존성 관리
application.yml : 서버 및 DB, 라이브러리 설정파일(properties로 관리를 해도 되지만 yml은 공통적인 부분을 많이 제거할 수 있다.)

SpringBootApplication
@Configuration, @EnableAutoConfiguration, @ComponentScan 세가지를 하나로 합친것이다.
@Configuration : 해당 클래스가 설정 파일임을 알려주는 용도
@ComponentScan : 자동으로 컴포넌트 클래스를 검색하여 컴포넌트와 빈 클래스를 등록함
@EnableAutoConfiguration : 스프링의 다양한 설정이 자동으로 구성되고 완료됨

3. 스프링의 핵심개념 IoC, DI
객체를 우리가 만드는 게아님 (부트가 알아서 만들어줌) -> IoC
스프링에게 객체를 만들어달라고 시키는법
클래스 앞에 컴포넌트 어노테이션 붙임
@Component public class Car{};
@Conponent Scan을 통해 @Component가 붙은 클래스를 전부 객체로 만들어서 컨테이너에 저장

DemoApplication 클래스 안에 Main이 서버가 돌게한다.
@SpringBootApplication
@Configuration : 해당 클래스가 설정파일임을 알려주는 어노테이션
@ComponentScan : 자동으로 컴포넌트어노테이션이 붙은 클래스를 검색하여 빈(Bean=객체)을 등록한다.
@EnableAutoConfiguration : 스프링의 다양한 설정이 자동으로 구성되고 완료된다.

컨테이너에는 Map으로 Key | Value로 저장한다.

1) DI(Dependency Injection) : 의존성 주입 ****
자바에서 클래스에 속해있는 메서드를 사용하기 위해 객체를 직접 생성했었다.
부트에서는 만들어진 Bean 을 가져다가 사용하는 형태

객체가 필요한 곳에 직접 넣는게 아닌, 컨테이너에 저장해 놓은 객체를 주입하는것
객체를 필요로 할때 스프링이 자동으로 주입을 해준다.

의존성주입방법
1) 필드 주입 
필요한 부분에 @Autowired로 붙힌다. 
순환참조시 오류 발생하지 않기 때문에 stackOverflow가 일어날 수 있다.
순환참조 안할꺼면 사용해도된다.

@Component  ---- Bettery를 Bean으로 만들어서 컨테이너에 저장
public class Battery{ ---객체컨테이너에 battery객체 저장됨
	int charge=90;
}

@Component
public class Toy{  ---객체컨테이너에 toy객체 저장됨
	@Autowired ---필드주입
	Bettery battery; ---- 베터리 객체가 필요함
}
기존엔
toy.battery -> null;
스프링이 객체를 넣어줌

순환참조 : Bean 간의 참조관계가 순환되어 발생하는 상황
A클래스가 B클래스의 빈을 주입받고, B클래스가 A클래스의 빈을 주입받는 상황

2) 생성자 주입
생성자를 만들고 주입이 필요한 필드를 매개변수로 받아서 주입

@Component
public class Battery{ ---객체컨테이너에 battery객체 저장됨
	int charge=90;
}

@RequiredArgsConstructor
@Component
public class Toy{  ---객체컨테이너에 toy객체 저장됨
	private final Bettery battery; ----final이나 @NonNull붙이고
	public Toy(bettery bettery){  매개변수로 들어옴 @Autowired 쓸필요 없다
		this.battery=battery;		
}
기존엔
toy.battery -> null;
스프링이 객체를 넣어줌


3) setter 주입 ->거의 안씀
setter메서드를 통해 객체를 주입받는다.


정리
스프링 어떻게 객체 저장?
@SpringBootApplication 어노테이션에 속해있는 @ComponentScan 어노테이션이 해당 파일 아래 경로에 있는
모든 패키지를 탐색하면서 @Component 어노테이션이 붙어있는 모든 클래스를 모두 Map형태로 저장한다.

클래스 이름의 첫글자를 소문자화 해서 key로 저장 Computer->computer
객체를 value로 만들어서 저장


3. Gradle 그래들 
자동화 빌드툴
플러그인
라이브러리 설치 -> 어떤 버전의 라이브러리를 설치하겠다. Gradle이 저장소로 가서 설치 도와준다
프로젝트의 버전관리

Gradle은 자바, 코틀린, 그루비(Groovy) 등 다양한 프로그래밍 언어를 지원하는 빌드 자동화 도구이다.
Gradle은 의존성 관리, 테스트 실행, 배포, 패키징 등의 빌드 작업을 자동화하며, 유연성과 확장성을 중시한다.
특히 멀티 프로젝트 빌드와 병렬 빌드에 강력한 성능을 발휘하며, 자바 기반 프로젝트에서는 Maven이나 Ant의 대안으로 많이 사용된다.

의존성 관리:
Gradle은 Maven Central, JCenter, Ivy 같은 의존성 저장소에서 외부 라이브러리를 쉽게 가져와 사용할 수 있도록 도와준다.
이를 통해 개발자는 필요한 라이브러리를 직접 다운로드하지 않고, 빌드 시 자동으로 라이브러리를 다운로드하고 관리할 수 있다.---필요하다고 하면 됨

DSL (Domain-Specific Language):
Gradle은 빌드 스크립트를 작성할 때 그루비(Groovy) 또는 코틀린(Kotlin) 기반의 DSL을 사용한다.
이 DSL을 사용해 빌드 로직을 간결하고 유연하게 작성할 수 있다.
build.gradle 파일에 그루비 기반으로 빌드 설정을 작성하거나, build.gradle.kts 파일에 코틀린 기반으로 작성할 수 있다.

플러그인 시스템:
Gradle은 다양한 플러그인을 제공하여 빌드 작업을 확장할 수 있습니다. 특히 자바, 스프링 부트, 안드로이드 개발에서 유용한 플러그인이 많이 사용됩니다.
예: java 플러그인, application 플러그인, spring-boot 플러그인, kotlin 플러그인 등.

build.gradle
프로젝트의 주요 빌드 설정을 정의하는 파일입니다. 여기에 의존성, 플러그인, 태스크(작업) 등을 정의할 수 있습니다.
https://mvnrepository.com/ 에서 링크 복사해서 여기에 dependencies 에 붙여넣으면 설치됨

plugins
Gradle에서 빌드 작업을 확장하고 자동화할 수 있도록 해주는 기능이다.
플러그인을 통해 다양한 기능을 추가할 수 있는데, 프로젝트에 필요한 빌드 작업이나 설정을 플러그인을 통해 쉽게 적용할 수 있다.
여러 작업을 미리 정의해둔 기능 모음이라고 생각하면 된다.


의존성 설정
implementation: 프로젝트에서 런타임(실행되는 시점)에 사용될 라이브러리를 정의한다.

spring-boot-starter-data-jpa: 스프링 부트에서 JPA(자바 퍼시스턴스 API)를 사용하기 위한 의존성이다.
spring-boot-starter-web: 웹 애플리케이션 개발을 위한 의존성이다. REST API, 웹 MVC 등을 지원한다.
com.google.guava:guava: 구글의 유명한 라이브러리인 Guava를 추가했다. 주로 컬렉션, 문자열 처리 등의 유틸리티 기능을 제공한다.
compileOnly: 컴파일 시에만 필요한 라이브러리이다. 주로 애노테이션 프로세서를 사용하지만, 런타임에는 포함되지 않는다.
org.projectlombok:lombok: Lombok은 자바 코드에서 반복적인 Getter, Setter, 생성자 등을 자동으로 생성해주는 라이브러리이다. 컴파일 시에만 필요하다.
runtimeOnly: 런타임에만 필요한 라이브러리를 정의한다.
com.h2database:h2: 내장형 데이터베이스 H2를 런타임에서 사용할 수 있도록 설정한다. 주로 테스트 환경이나 간단한 애플리케이션에서 사용된다.
annotationProcessor: 컴파일 타임에 애노테이션을 처리하는 라이브러리다. Lombok 같은 애노테이션 프로세서를 등록하는 곳이다.
testImplementation: 테스트 코드를 실행할 때 필요한 라이브러리이다.
spring-boot-starter-test: 스프링 부트에서 JUnit과 같은 테스트 기능을 제공하는 의존성이다.
testRuntimeOnly: 테스트 환경에서만 사용할 수 있는 라이브러리이다.
junit-platform-launcher: JUnit 테스트 실행기이다.

그래들
dependencies {
	implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
	implementation 'org.springframework.boot:spring-boot-starter-web'
	compileOnly 'org.projectlombok:lombok'
	runtimeOnly 'com.h2database:h2'
	annotationProcessor 'org.projectlombok:lombok'
	testImplementation 'org.springframework.boot:spring-boot-starter-test'
	testRuntimeOnly 'org.junit.platform:junit-platform-launcher'
	// https://mvnrepository.com/artifact/com.google.guava/guava
	implementation group: 'com.google.guava', name: 'guava', version: '33.3.1-jre'
	
}

디펜던시에 라이브러리 추가해보기
mvnrepository->https://mvnrepository.com/로 이동해서 guava를 검색한다.

4. 롬복(Lombok)
어노테이션으로 코딩에 필요한 코드를 대신만들어준다.
롬복을 사용하면 더 이상 getter/setter, builder, constructor를 작성하는 데 시간을 소모할 필요가 없다.
롬복이 제공하는 어노테이션 프로세서가 getter,setter,builder,constructor 프로젝트 컴파일 시 관련 코드를 자동으로 작성해준다.
따라서 롬복을 사용하면 코드의 양을 줄이고 개발 시간도 단축할 수 있다.
이클립스에서 롬복을 사용하려면 jar파일을 이용해 플러그인을 설치해야 한다.

@Getter : getter메서드 만들어줌
@Setter : setter메서드 만들어줌
@NoArgsConstructor : 매개변수 없는 기본생성자
@AllArgsConstructor : 모든 멤버를 매개변수로 가지는 생성자 생성

@RequiredArgsConstructor : final이나 @NonNull인 필드만 매개변수로 갖는 생성자 생성
@Data : getter,setter,requiredArgsConstructor,ToString,EqualsAndHashCode를 한번에 정의
@ToString : ToString 오버라이딩
@Builder : 빌더패턴을 사용할 수 있게 해주는 어노테이션 
@Builder
public class User{
	private String id;
	private String name;
	private String email;
}
User user=User.builder().id("1").name("홍길동").email("hong@example.com").build() 
이렇게 필드에 넣을 수 있다.
생성자 오버로딩을 줄일 수 있고, 객체를 단계적으로 생성할 수 있다.
유연한 객체생성이 가능
코드의 가독성 높임

5. 포스트맨
+ -> 요청방식 결정 -> 주소/리소스
서버 올리고 잘 작동하는지 보여주는 도구
REST API는 크게 나눠 URI, HTTP메서드, 요청 매개변수 또는 요청바디로 구분도는데, 이를 브라우저에서 테스팅하는 것에는 한계가 있다.
테스트를 한다고 임시로 프론트엔드 UI를 만드는 것은 지속가능한 방법이 아니다.
사용이 간편하고 직관적인 GUI를 제공하는 포스트맨이라는 프로그램을 사용한다.
포스트맨을 사용하면 간단히 RESTful API를 테스트 할 수 있다.
또 테스트를 저장해 API 스모크 테스팅 용으로 사용할 수 있다.

6. 백엔드 서비스 아키텍처
레이어드 아키택처 패턴 : 역할별로 레이어를 쪼갠다
요청->
표현 레이어 : 배분해주는 역할 DTO 숨길 수 있는건 숨기자 Controller  -@RestController 가 붙어야 설정이 된다.
-> 서비스 : 백엔드 로직 Model ---가공해서 컨트롤러로 전달해줌
-> 영속 개체 Enitity ----TodoEntity  한줄 자료 ist.add(TodoEntity)
-> 데이터 : DB

7. REST API --국룰
REST(Representational State Transfer) 아키텍처를 기반으로 하는 API(Application Programming Interface)다.
REST API는 클라이언트와 서버 간의 상호작용을 HTTP 프로토콜을 사용해 설계한 웹 서비스 인터페이스로, 
"데이터를 쉽게 주고받을 수 있게 해준다."
REST API는 웹 애플리케이션, 모바일 앱, 마이크로서비스 등 
다양한 시스템 간의 "통신을 위한 표준"으로 널리 사용된다.
REST 아키텍처 스타일은 6가지 제약조건으로 구성된다.
이 가이드를 따르는 API를 RESTful API라고 한다.

구조 : 클라이언트-서버

1) 상태가 없는(Stateless)
클라이언트가 서버에 요청을 보낼 때, "이전 요청의 영향을 받지 않음"을 의미한다.
예를들어 /login으로 로그인 요청을 보내고, 로그인이 되어 다음 페이지인 /page로 넘어갔다고 치자.
/page로 리소스를 불러올 때, 이전 요청에서 login한 사실을 서버가 알고 있어야 한다면 그것은 Stateful 상태가 된다.
Stateless상태를 유지하려면 서버는 그 사실을 몰라야 한다.
그렇기 때문에 로그인 상태를 유지하지 못하므로 요청을 보낼때마다 로그인 정보를 함께 보내야 한다.
http는 기본적으로 Stateless 프로토콜이다.

2) 캐시 가능한 데이터
서버에서 리소스를 반환할 때 캐시가 가능한지 아닌지 명시할 수 있어야 한다.
http에서는 cache-control이라는 헤더에 리소스의 캐시 여부를 명시할 수 있다.

※캐시
- 데이터를 빠르게 접근하기 위해 메모리나 디스크에 저장해두는 일종의 임시 저장소
- 캐시는 자주 사용되는 데이터를 임시로 저장해두고, 필요할 때 빠르게 가져다 사용할 수 있는 메커니즘이다.

3) 일관적인 인터페이스
GET: 리소스를 조회할 때 사용한다.
POST: 새로운 리소스를 생성할 때 사용한다.
PUT: 기존 리소스를 업데이트할 때 사용한다.
DELETE: 리소스를 삭제할 때 사용한다.

4) URI 구조의 일관성
URI 경로를 일관되게 설계하는 것도 중요하다.
리소스의 이름은 복수형으로 일관되게 사용하고, 리소스 간 관계를 표현할 때도 규칙적으로 작성해야 한다.

응답 형식의 일관성
모든 API의 응답 형식도 일관되게 설계해야 한다.
예를 들어, 성공 시 HTTP 상태 코드와 JSON 형식의 응답을 동일하게 유지하는 게 좋다.

5) 레이어 시스템
클라이언트는 여러 레이어를 인지하지 않고, 최종 서버에서 오는 응답만 신경 쓰게 된다.
클라이언트는 프록시, 캐시, 게이트웨이 등을 거치더라도 서버로부터 오는 결과만 받으면 된다.

6) 코드-온-디맨드(선택사항)
서버가 클라이언트에게 실행 가능한 코드를 전송하고, 클라이언트가 해당 코드를 실행할 수 있도록 하는 개념이다.

