

1 데이터베이스와 스프링 데이터 JPA 설정
1) H2 데이터베이스 관리 시스템
Hibernate 
이를 통해 개발자는 SQL을 직접 작성할 필요 없이, 자바 객체를 통해 데이터베이스 작업을 쉽게 수행할 수 있다.

장점
- 생산성 향상
개발자가 SQL 쿼리를 직접 작성하지 않고 객체 지향 방식으로 데이터베이스를 다룰 수 있게 하여, 개발 시간을 단축하고 코드의 가독성을 높여준다.
- 데이터베이스 독립성
데이터베이스에 의존하지 않고 동작하기 때문에, 데이터베이스 독립적으로 사용할 수 있다.
애플리케이션이 MySQL에서 Oracle로 변경되더라도 별도의 SQL 수정 없이 쉽게 전환할 수 있다.
- 자동화된 테이블 관리
애플리케이션의 엔티티 클래스를 분석하여 데이터베이스의 테이블을 자동으로 생성, 업데이트, 삭제할 수 있다.
개발자는 데이터베이스 스키마를 관리하는 수고를 덜 수 있다.
- 복잡한 관계 매핑 지원
1대1(One-to-One), 1대N(One-to-Many), **N대M(Many-to-Many)**와 같은 복잡한 엔티티 간의 관계를 쉽게 매핑할 수 있도록 한다.

단점
- 학습 곡선
복잡한 쿼리나 성능 최적화를 위한 설정은 처음 사용자가 이해하기 어려울 수 있다.
- 성능 문제
잘못된 설정이나 비효율적인 지연 로딩 사용은 성능 문제를 일으킬 수 있다.
SQL을 자동으로 생성하지만, 이를 충분히 이해하지 않고 사용할 경우 예상치 못한 성능 저하가 발생할 수 있다.
- ORM과 SQL 간의 불일치
객체 지향적인 자바의 모델링 방식과 데이터베이스의 관계형 모델링 방식은 서로 다르다.
복잡한 관계의 매핑에서는 여전히 ORM과 SQL 간의 불일치 문제가 존재할 수 있다.

2) JPA(Java Persistence API) ---인터페이스만 제공
자바에서 객체와 관계형 데이터베이스 간의 데이터를 매핑(ORM: Object-Relational Mapping)하기 위한 표준 API다.
JPA는 자바 객체를 데이터베이스의 테이블과 매핑하고, 데이터베이스의 데이터를 자바 객체로 변환하여 쉽게 다룰 수 있게 해준다.
이를 통해 개발자는 데이터베이스의 세부 사항에 구애받지 않고 객체 지향적으로 데이터베이스를 처리할 수 있다.

Entity
JPA에서 관리되는 자바 객체를 **엔티티(Entity)**라고 한다.
엔티티 클래스는 데이터베이스의 테이블과 매핑되며, 객체의 속성은 테이블의 컬럼과 매핑된다.
엔티티 클래스는 @Entity 애노테이션을 통해 정의된다.

Spring DAta JPA 
Spring Data JPA는 데이터베이스 작업을 더 쉽게 할 수 있도록 돕는 Spring Framework의 모듈이다.
Hibernate를 기반으로 사용하며, 데이터베이스 작업을 자동화하고, 데이터 액세스 로직을 단순화하는 데 중점을 둔다.
Spring Data JPA는 Repository 패턴을 기반으로 하여, 데이터베이스와 상호작용할 때 개발자가 반복적으로 작성해야 하는 코드들을 자동으로 처리해준다.

특징
-Repository 기반 데이터 액세스
Spring Data JPA는 Repository 인터페이스를 기반으로 데이터베이스에 접근한다.
이 인터페이스를 확장함으로써 복잡한 데이터 액세스 코드를 작성하지 않고도 CRUD(Create, Read, Update, Delete) 작업을 자동으로 처리할 수 있다.

-자동화된 CRUD 작업
Spring Data JPA는 기본적인 CRUD 메서드를 자동으로 제공한다.
JPA 인터페이스(JpaRepository)에서 제공하는 추상메서드들을 구현클래스에 Override할 필요없이 기본적인 데이터 베이스 작업을 처리할 수 있다.
JPARepository에서 제공하는 메서드
save(): 엔티티를 저장하거나 업데이트한다.
findById(): 기본 키를 사용해 엔티티를 조회한다.  Optional 이 반환형
deleteById(): 기본 키를 사용해 엔티티를 삭제한다.
findAll(): 모든 엔티티를 조회한다. select

Optional
findById()의 반환형이다.
**Optional**는 Java 8에 도입된 클래스로, null 값을 안전하게 처리하기 위해 사용된다.
findById() 메서드는 조회 결과가 존재할 수도 있고, 존재하지 않을 수도 있기 때문에, null을 반환하는 대신 Optional을 사용하여 결과를 감싸서 반환한다.
**Optional**는 해당 엔티티가 존재하는지 여부를 확인하고, 존재하면 그 값을 반환하며, 존재하지 않을 경우에 대해 추가적인 처리를 할 수 있는 다양한 메서드를 제공한다.

isPresent() : 반환된 Optional 객체 안에 값이 존재하면 true, 존재하지 않으면 false를 반환한다.
get() : Optional 안에 값이 존재할 때, 그 값을 반환한다. 만약 값이 없는데 get()을 호출하면 NoSuchElementException이 발생할 수 있다.
orElse(T other): 값이 존재하지 않을 때, 기본값을 반환한다.
orElseThrow(Supplier<? extends X> exceptionSupplier): 값이 없을 때, 예외를 던집니다.

-쿼리 메서드(Query Method)
JPA 쿼리 메서드를 작성할 때 메서드 이름만으로 SQL 쿼리를 자동 생성할 수 있다.
메서드 이름을 분석하여 해당 메서드에 맞는 SQL 문을 실행한다.
예를 들어, findByUsername(String username) 메서드는 자동으로 SELECT * FROM User WHERE username = ? 쿼리를 실행한다.
findBy는 붙여줘야한다.

테이블이 자동으로 생성되는 원리
Hibernate-> @Entity 보고 Class 이름을 테이블이름으로 만들어준다. 
기본키 @Id --nullX, 중복X, sequence 
@GeneratedValue(generator="system-uuid") ----sequence 

@GeneratedValue(generator="system-uuid") ---내가정한 규칙대로 id를 만들래@GeneratedValue는 JPA에서 기본 키 값을 자동으로 생성할 때 사용되는 어노테이션이다.
generator="system-uuid"는 특정 키 생성 전략을 참조하겠다는 의미로, 주로 Hibernate에서 제공하는 커스텀 생성 전략을 사용할 때 사용된다.
@GeneratedValue는 기본 키 값을 자동으로 생성하도록 하고, generator 속성은 커스텀 생성기를 참조하게 한다.
이 경우, **"system-uuid"**라는 이름의 생성기를 사용하여 UUID를 기본 키로 자동 생성하는 것이다.

@GenericGenerator(name="system-uuid", strategy="uuid") 
**"system-uuid"**라는 이름의 커스텀 생성기를 정의하고, 그 생성 전략으로 UUID를 사용하도록 설정한다.
이로 인해, UUID 형식의 고유한 식별자가 기본 키로 자동 생성된다.

UUID 생성방식 
Hibernate는 이 설정을 통해 UUID 4 방식을 사용하여 랜덤 UUID를 생성한다.
이는 128비트 크기의 고유 식별자로, 각 엔티티가 고유한 식별자를 가질 수 있게 해준다.

@Repository이 애노테이션은 주로 데이터베이스와 상호작용하는 클래스에서 사용되며, CRUD(Create, Read, Update, Delete)와 같은 데이터베이스 작업을 처리하는 데 사용된다.
@Repository가 붙은 클래스는 자동으로 **Spring의 빈(bean)**으로 등록된다.
이 빈은 애플리케이션의 다른 계층(서비스 계층 등)에서 주입받아 사용할 수 있다.
JpaRepository를 상속받는것과 같이 Spring Data JPA를 사용할 때는 @Repository는 자동으로 적용되기 때문에 생략할 수 있다.

JPQL (Java Persistence Query Language) 
JPA에서 사용하는 객체지향 쿼리 언어이다.
데이터베이스 테이블이 아닌 JPA 엔티티 객체를 대상으로 CRUD(생성, 조회, 수정, 삭제) 작업을 수행하는 쿼리를 작성할 수 있도록 설계되었다.

특징
-객체 지향적
JPQL은 데이터베이스 테이블 대신 JPA 엔티티 객체를 대상으로 쿼리를 실행합니다.
테이블 이름이나 컬럼 대신 엔티티 클래스 이름과 필드를 사용하여 쿼리를 작성한다.
이 때문에, JPQL 쿼리는 데이터베이스 독립적이며, 데이터베이스의 스키마에 의존하지 않는다.
-SQL과 유사한 구문
JPQL은 SQL과 매우 유사한 문법을 사용하지만, 엔티티 객체를 다룬다는 점에서 차이가 있다.
예를 들어, SQL에서 SELECT * FROM users는 JPQL에서는 SELECT u FROM User u로 표현된다.
여기서 User는 데이터베이스 테이블이 아닌 엔티티 클래스를 의미한다.


2. 로그--- 기록
소프트웨어 시스템이나 애플리케이션에서 동작 상태나 이벤트가 발생했을 때, 그 내용을 기록한 정보다.
개발자, 운영자, 또는 시스템이 해당 애플리케이션의 상태를 파악하거나 문제 해결을 위해 사용한다.
주로 애플리케이션의 실행 흐름, 오류 또는 성능 문제를 추적하고 분석하는 데 매우 중요한 도구다.
로그를 보고 오류 수정한다.

(1) 목적
-디버깅
애플리케이션에서 발생한 문제나 버그를 추적하고 원인을 파악하기 위해 사용된다.
디버깅 시 로그를 통해 애플리케이션이 어떤 작업을 하고 있었는지, 어떤 오류가 발생했는지를 알 수 있다.
-모니터링
애플리케이션이 예상대로 작동하는지 확인하고, 시스템 성능을 모니터링하기 위해 사용된다.
예를 들어, 응답 속도, 메모리 사용량 등을 로그로 기록하여 애플리케이션의 성능을 분석할 수 있다.
-문제 해결
애플리케이션에서 예상치 못한 상황이 발생했을 때, 로그를 통해 그 문제를 해결하는 데 필요한 정보를 얻을 수 있다.
특히, 시스템이 갑작스럽게 중단되거나 성능 저하가 발생했을 때, 그 원인을 파악하는 데 중요한 역할을 한다.
-보안 감사
애플리케이션에 대한 보안 감사 및 추적을 위해 사용된다.
시스템에 대한 접근 시도나 비정상적인 활동을 로그로 기록하여, 보안 위협을 감지하고 대응할 수 있다.

(2) 로그의 주요 구성 요소
-타임스탬프 : 로그가 기록된 시간. 이는 이벤트가 발생한 시점을 추적하는 데 매우 중요하다.
-로그 레벨(Log Level) : 로그의 중요도를 나타내며, 보통 아래와 같은 레벨이 사용된다.
TRACE: 가장 낮은 수준의 로그. 아주 상세한 디버깅 정보.
DEBUG: 개발 과정에서 주로 사용되는 디버깅 정보.
INFO: 시스템의 정상적인 동작을 나타내는 정보.
WARN: 예상치 못한 상황이 발생했지만, 시스템이 정상적으로 동작하는 경우.
ERROR: 오류가 발생했으며, 시스템이 정상적으로 동작하지 않는 경우.
FATAL: 매우 심각한 오류로, 시스템이 더 이상 동작할 수 없는 경우.
-메시지 : 로그에 기록된 이벤트에 대한 설명. 어떤 일이 일어났는지 명확하게 기술한다.
-이벤트 소스 : 로그가 기록된 위치, 예를 들어 특정 클래스, 메서드, 또는 모듈

(3) Slf4j(Simple Logging Facade for Java) --로그계의 JPA(추상화인터페이스)
Java 애플리케이션에서 사용하는 로깅 프레임워크에 대한 통합된 인터페이스를 제공하는 로그 추상화 라이브러리다.
SLF4J는 로그를 작성하는 표준 인터페이스를 제공하고, 
실제로 로그를 기록하는 것은 Logback, Log4j 같은 다른 로깅 프레임워크가 담당하는 방식이다.
인터페이스 제공, 추상메서드 제공 추상화 -> 구현체(overriding)

SLF4J의 역할
-로깅 프레임워크의 추상화
개발자가 SLF4J API를 사용하여 로그를 기록하면, SLF4J가 이를 구체적인 로깅 프레임워크에 전달한다.
스프링은 기본적으로 Logback 라이브러리를 사용한다.
-호환성 유지
SLF4J 덕분에 애플리케이션의 로깅 구현체를 변경할 때 기존 코드를 수정할 필요 없이 
로깅 라이브러리만 바꿔서 사용할 수 있다.



3. 객체 지향 설계 5대 원칙 SOLID
1) 단일 책임 원칙(SRP, Single Responsibiliy Principle)
하나의 메서드는 하나의 책임만 가져야한다.

2) 개방 폐쇄 원칙(OCP, Open-Closed Principle)
상속에는 Open, 변경에는 Close해야한다. 
코드를 변경할 일이 있으면 변경하지 말고, 상속을 써라

3) 리스코프 치환 원칙(LSP, Liskov Subtitution Principle)
같은 조상의 다른 클래스로 바꿔도 동작해야한다.(다형성)
Spring Data JPA -> Hibernate 를 다른 구현체로 바꿔도 문제가 되지 않는다.
lsf4j -> Logback, Log4j같이 다른 구현체로 바꿔도 문제가 생기지 않는다.

4) 인터페이스 분리 원칙(ISP, Interface Segregation Principle)
유사한 인터페이스가 있더라도 목적이 다르면 분리해야한다.

5) 의존관계 역전 원칙(DIP, Dependency Inversion Principle)
추상화 의존한 코드를 작성해야한다.
코드가 너무 구체적이면 변경이 불리하다.

4. Todo서비스 만들기

영속레이서 -> 서비스레이어 -> 표현레이어 순으로 구현

1) 클라이언트로부터 요청을 받았을 때

Request     >      TodoController        > 	TodoService 	 > Repository  	> DB
                 TodoDTO > TodoEntity				DB처리 로직 담음

조회 		@GetMapping		findAll()
-전체조회
-특정유저 작성한 내용만 조회
추가		@PostMapping
수정		@PutMapping
삭제		@DeleteMapping


2) 클라이언트에게 응답을 보낼 때
Response    <      TodoController        < 	TodoService 	 < Repository 	< DB
                 TodoDTO < TodoEntity				DB처리 로직 담음

3) JPA
쿼리문 대신에 JpaRepository 가 메서드를 제공한다.
JPA가 메서드의 이름을 읽어서 쿼리문을 생성해준다.

추가,수정 : save( )
조회 : findAll( ), findBy00( )
삭제 : Delete( )

findBy : 특정 조건에 맞는 데이터를 조회
countBy :  특정 조건에 맞는 데이터의 개수를 조회
deleteBy :  특정 조건에 맞는 데이터를 삭제
existsBy : 특정 조건에 맞는 데이터가 존재하는지 여부를 확인

메서드명에 다양한 조건자를 함께 사용할 수 있다.
And : 두조건을 모두 만족하는 데이터 조회
Or : 두 조건중 하나라도 만족하는 데이터 조회
Between : 두값 사이에 있는 데이터 조회
Less Than / Greater Than : 특정 값보다 작은 또는 큰 데이터 조회
Like : 부분일치 검색

userName이 John인 사람 찾기
List<User>findByUserName(String name);

나이가 30보다 큰 사용자 찾기
List<User> findByAgeGreaterThan(int age)

이름이 John이고 나이가 30보다 많은 사용자 찾기
List<User>findByUsernameAndAgeGreaterThan(String name,int age)

이름이 Jone 이거나 나이가 30보다 많은 사용자 찾기
List<User>findByUsernameOrAgeGreaterThan(String name, int age)





JSON
{ "key1" : 123, "key2" : "문자" } 

1) create todo  구현
-> todo 아이템을 데이터베이스에 추가하는기능

2) update todo 구현
TodoRepository
save(), findByUserId();

서비스계층
TodoService에 update()메서드를 작성

3)DeleteTodo 기능 구현
-Todo를 삭제하기 위한 기능
영속계층
TodoRepository의 delete(),findByUserId()메서드를 사용할것

서비스계층
delete()메서드 만들기

표현계층
delete()메서드





